# 1 基本数据结构
- 4种简单而强大的数据结构：**栈**、**队列**、**双端队列**和**列表**。它们都是有序的数据集合，其元素的顺序取决于添加顺序或移除顺序。
- **线性数据结构**：一旦某个元素被添加进来，它与前后元素的相对位置将保持不变。

## 1.1 栈
### 1.1.1 何谓栈
- **栈**是有序集合，添加操作和移除操作总发生在同一端，即“顶端”，另一端则被称为“底端”。
- 最新添加的元素将被最先移除，这种排序原则被称作**LIFO**（last-in first-out），即后进先出。

### 1.1.2 栈抽象数据类型
1. `Stack()`创建一个空栈。它不需要参数，且会返回一个空栈。
2. `push(item)`将一个元素添加到栈的顶端。它需要一个参数`item`，且无返回值。
3. `pop()`将栈顶端的元素移除。它不需要参数，但会返回顶端的元素，并且修改栈的内容。
4. `peek()`返回栈顶端的元素，但是并不移除该元素。它不需要参数，也不会修改栈的内容。
5. `isEmpty()`检查栈是否为空。它不需要参数，且会返回一个布尔值。
6. `size()`返回栈中元素的数目。它不需要参数，且会返回一个整数。

### 1.1.3 用Python实现栈
```python
class Stack:
    def __init__(self):
        self.items = []
    
    def isEmpty(self):
        return self.items == []
    
    def push(self, item):
        return self.items.append(item)
    
    def pop(self):
        return self.items.pop()
    
    def peek(self):
        return self.items[-1]
    
    def size(self):
        return len(self.items)
```
```python
>>> s = Stack() # 栈内容：[]
>>> s.isEmpty() # 栈内容：[]
True
>>> s.push(4) # 栈内容：[4]
>>> s.push('dog') # 栈内容：[4, 'dog']
>>> s.peek() # 栈内容：[4, 'dog']
'dog'
>>> s.push(True) # 栈内容：[4, 'dog', True]
>>> s.size() # 栈内容：[4, 'dog', True]
3
>>> s.isEmpty() # 栈内容：[4, 'dog', True]
False
>>> s.push(8.4) # 栈内容：[4, 'dog', True, 8.4]
>>> s.pop() # 栈内容：[4, 'dog', True]
8.4
>>> s.pop() # 栈内容：[4, 'dog']
True
>>> s.size() # 栈内容：[4, 'dog']
2
```

### 1.1.4 匹配括号
- 由一个空栈开始，从左往右依次处理括号。
- 如果遇到左括号，便通过`push`操作将其加入栈中，以此表示稍后需要有一个与之匹配的右括号。
- 反之，如果遇到右括号，就调用`pop`操作。
- 只要栈中的所有左括号都能遇到与之匹配的右括号，那么整个括号串就是就是匹配的；如果栈中有任何一个左括号找不到与之匹配的右括号，则括号串就是不匹配的。
- 在处理完匹配的括号串之后，栈应该是空的。
```python
def parChecker(symbolString):
    s = Stack()
    balanced = True
    index = 0
    while index < len(symbolString) and balanced:
        symbol = symbolString[index]
        if symbol == '(':
            s.push(symbol)
        else:
            if s.isEmpty():
                balanced = False
            else:
                s.pop()
        
        index += 1
    
    if balanced and s.isEmpty():
        return True
    else:
        return False
```
```python
>>> parChecker('(()()())')
True
>>> parChecker('(((())))')
True
>>> parChecker('(()((())()))')
True
>>> parChecker('((((((())')
False
>>> parChecker('()))')
False
>>> parChecker('(()()(()')
False
```

### 1.1.5 普通情况：匹配符号
- 要处理新类型的符号，可以轻松扩展括号匹配检测器。
- 每一个左符号都将被压入栈中，以待之后出现对应的右括号。
- 唯一的区别在于，当出现右符号时，必须检测其类型是否与栈顶的左符号类型相匹配。
- 如果两个符号不匹配，那么整个符号串也就不匹配。
- 同样，如果整个符号串处理完成并且栈是空的，那么就说明所有符号正确匹配。
```python
def parChecker(symbolString):
    s = Stack()
    
    balanced = True
    index = 0
    
    while index < len(symbolString) and balanced:
        symbol = symbolString[index]
        if symbol in '([{':
            s.push(symbol)
        else:
            if s.isEmpty():
                balanced = False
            else:
                top = s.pop()
                if not matches(top, symbol):
                    balanced = False
        
        index += 1
    
    if balanced and s.isEmpty():
        return True
    else:
        return False

def matches(left, right):
    lefts = '([{'
    rights = ')]}'
    
    return lefts.index(left) == rights.index(right)
```
```python
>>> parChecker('{{([][])}()}')
True
>>> parChecker('[[{{(())}}]]')
True
>>> parChecker('[][][](){}')
True
>>> parChecker('([)]')
False
>>> parChecker('((()]))')
False
>>> parChecker('[{()]')
False
```

### 1.1.6 将十进制数转换成二进制数
1. 233~10~ = 2 x 10^2^ + 3 x 10^1^ + 3  x 10^0^
2. 11101001~2~ = 1 x 2^7^ + 1 x 2^6^ + 1 x 2 ^5^ + 0 x 2 ^4^ + 1 x 2 ^3^ + 0 x 2 ^2^  + 0 x 2 ^1^ + 1 x 2 ^0^
- “除以2”算法用一个简单的循环不停地将十进制数除以2，并且记录余数。
- 第一次除以2的结果能够用于区分奇数和偶数。
- 如果是偶数，则余数为0，因此个位上的数字为0；如果是奇数，则余数为1，因此个位上的数字为1。
- 可以将要构建的二进制数看成一系列数字；计算出的第一个余数是最后一位。
```python
def divideBy2(decNumber):
    remstack = Stack()
    
    while decNumber > 0:
        rem = decNumber % 2
        remstack.push(rem)
        decNumber = decNumber // 2
    
    binString = ''
    while not remstack.isEmpty():
        binString = binString + str(remstack.pop())
    
    return binString
```
```python
>>> divideBy2(233)
'11101001'
```
- 可以将`divideBy2`函数修改成接受一个十进制数以及希望转换的进制基数，“除以2”则变成“除以基数”。
- 当基数超过10时，不能再直接使用余数，这是因为余数本身就是两位的十进制数。
- 因此，需要创建一套数字来标示大于9的余数。
```python
def baseConverter(decNumber, base):
    digits = '0123456789ABCDEF'
    
    remstack = Stack()
    
    while decNumber > 0:
        rem = decNumber % base
        remstack.push(rem)
        decNumber = decNumber // base
    
    newString = ''
    while not remstack.isEmpty():
        newString = newString + digits[remstack.pop()]
    
    return newString
```
```python
>>> baseConverter(233, 8)
'351'
>>> baseConverter(233, 16)
'E9'
```

### 1.1.7 前序、中序和后序表达式
- 前序和后序表达式不需要括号，这两种表达式中的运算符所对应的操作数是明确的。
- 只有中序表达式需要额外的符号来消除歧义。
- 若要将任意复杂的中序表达式转换成前序表达式或后序表达式，可以先将其写作完全括号表达式，然后将括号内的运算符移到左括号处（前序表达式）或者右括号处（后序表达式）。

#### 1.1.7.1 从中序到后序的通用转换法
当遇到左括号时，需要将其保存，以表示接下来会遇到高优先级的运算符；那个运算符需要等到对应的右括号出现才能确定其位置；当右括号出现时，便可以将运算符从栈中取出来。
1. 创建用于保存运算符的空栈`opStack`，以及一个用于保存结果的空列表。
2. 使用字符串方法`split`将输入的中序表达式转换成一个列表。
3. 从左往右扫描这个标记列表。
    - 如果标记是操作数，将其添加到结果列表的末尾。
    - 如果标记是左括号，将其压入`opStack`栈中。
    - 如果标记是右括号，反复从`opStack`栈中移除元素，直到移除对应的左括号。将从栈中取出的每一个运算符都添加到结果列表的末尾。
    - 如果标记是运算符，将其压入`opStack`栈中。但是，在这之前，需要先从栈中取出优先级更高或相同的运算符，并将它们添加到结果列表的末尾。
4. 当处理完输入表达式以后，检查`opStack`。将其中所有残留的运算符全部添加到结果列表的末尾。
```python
import string

def infixToPostfix(infixexpr):
    prec = {}
    prec['*'] = 3
    prec['/'] = 3
    prec['+'] = 2
    prec['-'] = 2
    prec['('] = 1
    
    opStack = Stack()
    postfixList = []
    
    tokenList = infixexpr.split()
    
    for token in tokenList:
        if token in string.ascii_uppercase:
            postfixList.append(token)
        elif token == '(':
            opStack.push(token)
        elif token == ')':
            topToken = opStack.pop()
            while topToken != '(':
                postfixList.append(topToken)
                topToken = opStack.pop()
        else:
            while (not opStack.isEmpty()) and (prec[opStack.peek()] >= prec[token]):
                postfixList.append(opStack.pop())
            opStack.push(token)
    
    while not opStack.isEmpty():
        postfixList.append(opStack.pop())
    
    return ' '.join(postfixList)
```
```python
>>> infixToPostfix('( A + B ) * ( C + D )')
'A B + C D + *'
>>> infixToPostfix('( A + B ) * C')
'A B + C *'
>>> infixToPostfix('A + B * C')
'A B C * +'
```

#### 1.1.7.2 计算后序表达式
当遇到一个运算符时，需要用离它最近的两个操作数来计算。
1. 创建空栈`operandStack`。
2. 使用字符串方法`split`将输入的后序表达式转换成一个列表。
3. 从左往右扫描这个标记列表。
    - 如果标记是操作符，将其转换成整数并且压入`operandStack`栈中。
    - 如果标记是运算符，从`operandStack`栈中取出两个操作数。第一次取出右操作数，第二次取出左操作数。进行相应的算术运算，然后将运算结果压入`operandStack`栈中。
4. 当处理完输入表达式时，栈中的值就是结果。将其从栈中返回。
```python
def postfixEval(postfixExpr):
    operandStack = Stack()
    
    tokenList = postfixExpr.split()
    
    for token in tokenList:
        if token in '0123456789':
            operandStack.push(token)
        else:
            operand2 = operandStack.pop()
            operand1 = operandStack.pop()
            result = doMath(token, int(operand1), int(operand2))
            operandStack.push(result)
    
    return operandStack.pop()

def doMath(op, op1, op2):
    if op == '*':
        return op1 * op2
    elif op == '/':
        return op1 / op2
    elif op == '+':
        return op1 + op2
    else:
        return op1 - op2
```
```python
>>> postfixEval('4 5 6 * +')
34
>>> postfixEval('7 8 + 3 2 + /')
3
```

## 1.2 队列
### 1.2.1 何谓队列
### 1.2.2 队列抽象数据类型
### 1.2.3 用Python实现队列
### 1.2.4 模拟：传土豆
### 1.2.5 模拟：打印任务

## 1.3 双端队列
### 1.3.1 何谓双端队列
### 1.3.2 双端队列抽象数据类型
### 1.3.3 用Python实现双端队列
### 1.3.4 回文检测器

## 1.4 列表
### 1.4.1 无序列表抽象数据类型
### 1.4.2 实现无序列表：链表
### 1.4.3 有序列表抽象数据类型
### 1.4.4 实现有序列表