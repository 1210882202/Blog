[toc]

# 3 搜索和排序
## 3.1 搜索
- 搜索时指从元素集合中找到某个特定元素的算法过程。

### 3.1.1 顺序搜索
- 无序列表的顺序搜索
```python
def sequentialSearch(alist, item):
    pos = 0
    found = False
    
    while pos < len(alist) and not found:
        if alist[pos] == item:
            found = True
        else:
            pos += 1
    
    return found
```
```python
>>> sequentialSearch([54, 26, 93, 17, 77, 31, 44, 55, 20, 65], 31)
True
>>> sequentialSearch([54, 26, 93, 17, 77, 31, 44, 55, 20, 65], 40)
False
```
- 有序列表的顺序搜索
```python
def orderedSequentialSearch(alist, item):
    pos = 0
    found = False
    stop = False
    while pos < len(alist) and not found and not stop:
        if alist[pos] == item:
            found = True
        else:
            if alist[pos] > item:
                stop = True
            else:
                pos += 1
    
    return found
```
```python
>>> orderedSequentialSearch([17, 20, 26, 31, 44, 54, 55, 65, 77, 93], 54)
True
>>> orderedSequentialSearch([17, 20, 26, 31, 44, 54, 55, 65, 77, 93], 56)
False
```

### 3.1.2 二分搜索
- 二分搜索不是从第一个元素开始搜索列表，而是从中间的元素着手。
- 如果这个元素就是目标元素，那就立即停止搜索；如果不是，则可以利用列表有序的特性，排除一半的元素。
- 如果目标元素比中间的元素大，就可以直接排除列表的左半部分和中间元的元素。
- 接下来，针对右半部分重复二分过程。
```python
def binarySearch(alist, item):
    first = 0
    last = len(alist) - 1
    found = False
    
    while first <= last and not found:
        midpoint = (first + last) // 2
        if alist[midpoint] == item:
            found = True
        else:
            if item < alist[midpoint]:
                last = midpoint - 1
            else:
                first = midpoint + 1
    
    return found
```
```python
>>> binarySearch([17, 20, 26, 31, 44, 54, 55, 65, 77, 93], 54)
True
>>> binarySearch([17, 20, 26, 31, 44, 54, 55, 65, 77, 93], 56)
False
```
- 二分搜索的递归版本
```python
def binarySearch(alist, item):
    if len(alist) == 0:
        return False
    else:
        midpoint = len(alist) // 2
        if alist[midpoint] == item:
            return True
        else:
            if item < alist[midpoint]:
                return binarySearch(alist[:midpoint], item)
            else:
                return binarySearch(alist[midpoint+1:], item)
```
```python
>>> binarySearch([17, 20, 26, 31, 44, 54, 55, 65, 77, 93], 54)
True
>>> binarySearch([17, 20, 26, 31, 44, 54, 55, 65, 77, 93], 56)
False
```

## 3.2 排序
- 排序是指将集合中的元素按某种顺序排列的过程。

### 3.2.1 冒泡排序
- **冒泡排序**多次遍历列表。
- 它比较相邻的元素，将不合顺序的交换。
- 每一轮遍历都将下一个最大值放到正确的位置上。
```python
def bubbleSort(alist):
    for passnum in range(len(alist)-1, 0, -1):
        for i in range(passnum):
            if alist[i] > alist[i+1]:
                temp = alist[i]
                alist[i] = alist[i+1]
                alist[i+1] = temp
```
```python
>>> sample = [54, 26, 93, 17, 77, 31, 44, 55, 20]
>>> bubbleSort(sample)
>>> print(sample)
[17, 20, 26, 31, 44, 54, 55, 77, 93]
```
- 冒泡排序通常被认为是效率最低的排序算法，因为在确定最终的位置前必须交换元素。
- 由于冒泡排序要遍历列表中未排序的部分，因此它具有其他排序算法没有的用途。
- 特别是，如果在一轮遍历中没有发生元素交换，就可以确定列表已经有序。
- **短冒泡**
```python
def bubbleSort(alist):
    exchanges = True
    passnum = len(alist)-1
    while passnum > 0 and exchanges:
        exchanges = False
        for i in range(passnum):
            if alist[i] > alist[i+1]:
                exchanges = True
                temp = alist[i]
                alist[i] = alist[i+1]
                alist[i+1] = temp
        passnum -= 1
```

### 3.2.2 选择排序

### 3.2.3 插入排序
### 3.2.4 希尔排序
### 3.2.5 归并排序
### 3.2.6 快速排序