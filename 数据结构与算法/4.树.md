[toc]

# 4 树
## 4.1 实现
1. `BinaryTree()`创建一个二叉树实例。
2. `getLeftChild()`返回当前节点的左子节点所对应的二叉树。
3. `getRightChild()`返回当前节点的右子节点所对应的二叉树。
4. `setRootVal(val)`在当前节点中存储参数`val`中的对象。
5. `getRootVal()`返回当前节点存储的对象。
6. `insertLeft(val)`新建一颗二叉树，并将其作为当前节点的左子节点。
7. `insertRight(val)`新建一颗二叉树，并将其作为当前节点的右子节点。

### 4.1.1 列表之列表
```python
def BinaryTree(r):
    return [r, [], []]

def insertLeft(root, newBranch):
    t = root.pop(1)
    if len(t) > 1:
        root.insert(1, [newBranch, t, []])
    else:
        root.insert(1, [newBranch, [], []])
    return root

def insertRight(root,newBranch):
    t = root.pop(2)
    if len(t) > 1:
        root.insert(2, [newBranch, [], t])
    else:
        root.insert(2, [newBranch, [], []])
    return root

def getRootVal(root):
    return root[0]

def setRootVal(root, newVal):
    root[0] = newVal

def getLeftChild(root):
    return root[1]

def getRightChild(root):
    return root[2]
```
```python
>>> r = BinaryTree(3)
>>> insertLeft(r, 4)
[3, [4, [], []], []]
>>> insertLeft(r, 5)
[3, [5, [4, [], []], []], []]
>>> insertRight(r, 6)
[3, [5, [4, [], []], []], [6, [], []]]
>>> insertRight(r, 7)
[3, [5, [4, [], []], []], [7, [], [6, [], []]]]
>>> l = getLeftChild(r)
>>> print(l)
[5, [4, [], []], []]
>>> setRootVal(l, 9)
>>> print(r)
[3, [9, [4, [], []], []], [7, [], [6, [], []]]]
>>> insertLeft(l, 11)
[9, [11, [4, [], []], []], []]
>>> print(r)
[3, [9, [11, [4, [], []], []], []], [7, [], [6, [], []]]]
>>> print(getRightChild(getRightChild(r)))
[6, [], []]
```

### 4.1.2 节点与引用
```python
class BinaryTree:
    def __init__(self, rootObj):
        self.key = rootObj
        self.leftChild = None
        self.rightChild = None

    def insertLeft(self, newNode):
        if self.leftChild == None:
            self.leftChild = BinaryTree(newNode)
        else:
            t = BinaryTree(newNode)
            t.leftChild = self.leftChild
            self.leftChild = t

    def insertRight(self,newNode):
        if self.rightChild == None:
            self.rightChild = BinaryTree(newNode)
        else:
            t = BinaryTree(newNode)
            t.rightChild = self.rightChild
            self.rightChild = t

    def getRightChild(self):
        return self.rightChild

    def getLeftChild(self):
        return self.leftChild

    def setRootVal(self,obj):
        self.key = obj

    def getRootVal(self):
        return self.key
```
```python
>>> r = BinaryTree('a')
>>> print(r.getRootVal())
'a'
>>> print(r.getLeftChild())
None
>>> r.insertLeft('b')
>>> print(r.getLeftChild())
<__main__.BinaryTree object>
>>> print(r.getLeftChild().getRootVal())
'b'
>>> r.insertRight('c')
>>> print(r.getRightChild())
<__main__.BinaryTree object>
>>> print(r.getRightChild().getRootVal())
'c'
>>> r.getRightChild().setRootVal('hello')
>>> print(r.getRightChild().getRootVal())
'hello'
```

## 4.2 二叉树的应用
### 4.2.1 解析树
1. 如果当前标记是`(`，就为当前节点添加一个左子节点，并下沉至孩子节点；
2. 如果当前标记在列表`['+', '-', '/', '*']`中，就将当前节点的值设为当前标记对应的运算符；为当前节点添加一个右子节点，并下沉至该子节点；
3. 如果当前标记是数字，就将当前节点的值设为这个数并返回至父节点；
4. 如果当前标记是`)`，就跳到当前节点的父节点。
- 在遍历树时使用栈记录父节点。
```python
def buildParseTree(fpexp):
    fplist = fpexp.split()
    pStack = Stack()
    eTree = BinaryTree('')
    pStack.push(eTree)
    currentTree = eTree
    for i in fplist:
        if i == '(':
            currentTree.insertLeft('')
            pStack.push(currentTree)
            currentTree = currentTree.getLeftChild()
        elif i not in '+-*/)':
            currentTree.setRootVal(eval(i))
            parent = pStack.pop()
            currentTree = parent
        elif i in '+-*/':
            currentTree.setRootVal(i)
            currentTree.insertRight('')
            pStack.push(currentTree)
            currentTree = currentTree.getRightChild()
        elif i == ')':
            currentTree = pStack.pop()
        else:
            raise ValueError(f'Unknown Operator: {i}')
    return eTree
```
```python
>>> t = buildParseTree('( 3 + ( 4 * 5 ) )')
>>> print(t.getRootVal())
'+'
>>> print(t.getLeftChild().getRootVal())
3
>>> print(t.getRightChild().getRootVal())
'*'
>>> print(t.getRightChild().getLeftChild().getRootVal())
4
>>> print(t.getRightChild().getRightChild().getRootVal())
5
```
- 我们可以写一个函数计算解析树，并返回计算结果。
```python
import operator

def evaluate(parseTree):
    opers = {'+':operator.add,
             '-':operator.sub,
             '*':operator.mul,
             '/':operator.truediv}
    leftC = parseTree.getLeftChild()
    rightC = parseTree.getRightChild()

    if leftC and rightC:
        fn = opers[parseTree.getRootVal()]
        return fn(evaluate(leftC), evaluate(rightC))
    else:
        return parseTree.getRootVal()
```
```python
>>> evaluate(t)
23
```

### 4.2.2 树的遍历
- 遍历按节点的访问方式分为3种：**前序遍历**、**中序遍历**和**后序遍历**。
- 前序遍历：先访问根节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树。
- 中序遍历：先递归地中序遍历左子树，然后访问根节点，最后递归地中序遍历右子树。
- 后序遍历：先递归地后序遍历左子树，然后递归地后序遍历右子树，最后访问根节点。

## 4.3 利用二叉树实现优先级队列
### 4.3.1 二叉堆的操作
### 4.3.2 二叉堆的实现

## 4.4 二叉搜索树
### 4.4.1 搜索树的操作
### 4.4.2 搜索树的实现
### 4.4.3 搜索树的分析

## 4.5 平衡二叉搜索树
### 4.5.1 AVL树的性能
### 4.5.2 AVL树的实现
### 4.5.3 映射实现总结